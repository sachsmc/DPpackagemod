{
    "collab_server" : "",
    "contents" : "c=======================================================================                      \n      subroutine dpdenregr(nrec,nx,nvar,nmissi,nmiss,z,missp,npred,\n     &                     xpred,ngrid,grid,  \n     &                     a0b0,k0,nuvec,s2inv, \n     &                     s2invm2, \n     &                     psiinv2,tau,mcmc,nsave,\n     &                     cpo,thetasave,denspm,denspl,densph, \n     &                     meanfpm,meanfpl,meanfph, \n     &                     alpha,m1,muclus,ncluster,\n     &                     psi1,psiinv1,s1,sigmaclus,ss,ccluster,cstrt,\n     &                     iflag,num,denom,fs,fm, \n     &                     muwork,prob,seed,sigmawork,sigworkinv,theta,\n     &                     workm1,workm2,workm3,workmh1,workmh2,workv1,\n     &                     workv2,workv3,ywork,\n     &                     iflagx,workvx,workmx,worksam,\n     &                     numcpo,denomcpo)\nc=======================================================================                      \nc     # of arguments = 64.\nc\nc     Subroutine `dpdenregr' to run a Markov chain in the DP mixture of  \nc     normals model for conditional density estimation. \nc\nc     In this routine, inference is based on the \nc     Polya urn representation of the Dirichlet process. The algorithm\nc     8 of Neal (2000) is used with m=1. \nc\nc     Copyright: Alejandro Jara, 2008-2010.\nc\nc     Version 1.0: \nc\nc     Last modification: 25-06-2008.\nc\nc     This program is free software; you can redistribute it and/or modify\nc     it under the terms of the GNU General Public License as published by\nc     the Free Software Foundation; either version 2 of the License, or (at\nc     your option) any later version.\nc\nc     This program is distributed in the hope that it will be useful, but\nc     WITHOUT ANY WARRANTY; without even the implied warranty of\nc     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nc     General Public License for more details.\nc\nc     You should have received a copy of the GNU General Public License\nc     along with this program; if not, write to the Free Software\nc     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\nc\nc     The author's contact information:\nc\nc      Alejandro Jara\nc      Department of Statistics\nc      Facultad de Matematicas\nc      Pontificia Universidad Catolica de Chile\nc      Casilla 306, Correo 22 \nc      Santiago\nc      Chile\nc      Voice: +56-2-3544506  URL  : http://www.mat.puc.cl/~ajara\nc      Fax  : +56-2-3547729  Email: atjara@uc.cl\nc\nc---- Data -------------------------------------------------------------\nc \nc        nmissi      :  integer indicating whether the data contain\nc                       (1) or not (0) missing data. \nc        nmiss       :  integer giving the number of missing data \nc                       points. \nc        missp       :  integer matrix giving the location of the\nc                       missing data points, missp(nmiss,2).\nc        nrec        :  integer giving the number of observations.\nc        nvar        :  integer giving the number of variables.\nc        nx          :  integer giving the number of predictors.\nc        z           :  real matrix giving the response variables,\nc                       z(nrec,nvar).\nc\nc---- Predictions ------------------------------------------------------\nc \nc        cband       :  integer value indicating whether the \nc                       credible bands need to be computed or not.\nc        ngrid       :  integer giving the size of the grid where\nc                       the densities will be evaluated.\nc        grid        :  real vector giving the grid of values for\nc                       the response, grid(ngrid).\nc        npred       :  integer giving the number of predictions.\nc        tband       :  integer indicating the type of credible \nc                       band that need to be computed.\nc        xpred       :  real matrix giving the value of the\nc                       predictors for prediction, xpred(npred,nx).\nc\nc-----------------------------------------------------------------------\nc\nc---- Prior information ------------------------------------------------\nc \nc        aa0, ab0    :  reals giving the hyperparameters of the prior\nc                       distribution for the precision parameter,\nc                       alpha ~ Gamma(aa0,ab0). If aa0<0 the precision \nc                       parameter is considered as a constant.\nc        nu1         :  integer giving the degrees of freedom for the\nc                       inverted-Wishart component of the baseline\nc                       distribution.\nc        nu2         :  integer giving the degrees of freedom for the\nc                       inverted-Wishart prior distribution for the\nc                       covariance matrix of the normal component of\nc                       the baseline distribution.\nc        m1rand      :  integer indicating wether m1 should be held \nc                       fix, 0, or random, 1.\nc        s2inv       :  real matrix giving the precision of the normal\nc                       prior distribution on the mean of the normal \nc                       component of the baseline distribution,\nc                       s2inv(nvar,nvar).\nc        s2invm2     :  real vector giving the the product of precision \nc                       matrix and the prior mean of the normal\nc                       prior distribution on the mean of the normal \nc                       component of the baseline distribution,\nc                       s2ivm2(nvar).\nc        tau1, tau2  :  reals giving the hyperparameters of the prior \nc                       distribution for k0, k0 ~ Gamma(tau1/2,tau2/2).\nc        psiinv2     :  real matrix giving the inverse of the scale \nc                       matrix for the inverted-Wishart prior on the\nc                       variance matrix of the normal component of \nc                       the baseline distribution, psiinv2(nvar,nvar).\nc\nc        NOTE        :  the inverted-Wishart here is parametrized,\nc                       sigma ~ Inv-Wishart(nu0,tinv^{-1}), such that \nc                       E(sigma)=(1/(nu0-q-1)) * tinv\nc\nc-----------------------------------------------------------------------\nc\nc---- MCMC parameters --------------------------------------------------\nc\nc        nburn       :  integer giving the number of burn-in scans.\nc        ndisplay    :  integer giving the number of saved scans to be\nc                       displayed on screen.\nc        nskip       :  integer giving the thinning interval.\nc        nsave       :  integer giving the number of scans to be saved.\nc        \nc-----------------------------------------------------------------------\nc\nc---- Output -----------------------------------------------------------\nc\nc        cpo         :  real matrix giving the cpo's. \nc        thetasave   :  real matrix containing the mcmc samples for\nc                       the parameters, \nc        meansave    :  real matrix containing the mcmc samples for\nc                       the conditional means. \nc                       thetasave(nsave,nvar+nvar*(nvar+1)/2+3).\nc        denspm      :  real matrix giving the posterior means for the\nc                       conditional densities, denspm(npred,ngrid).\nc        denspl      :  real matrix giving the lower limit for the\nc                       95%HPD for the conditional densities, \nc                       denspl(npred,ngrid).\nc        densph      :  real matrix giving the upper limit for the\nc                       95%HPD for the conditional densities, \nc                       densph(npred,ngrid).\nc        meanfpm     :  real vector giving the posterior means for the\nc                       conditional means, meanfpm(npred).\nc        meanfpl     :  real vector giving the lower limit for the\nc                       95%HPD for the conditional means, \nc                       meanfpl(npred).\nc        meanfph     :  real vector giving the upper limit for the\nc                       95%HPD for the conditional means, \nc                       meanfph(npred).\nc\nc-----------------------------------------------------------------------\nc\nc---- Current value of the parameters ----------------------------------\nc\nc        alpha       :  real giving the current value of the precision\nc                       parameter of the Dirichlet process.\nc        k0          :  real giving the precision parameter for the \nc                       normal baseline\nc        m1          :  real vector giving the mean of the normal \nc                       component of the baseline distribution, m1(nvar)\nc        muclus      :  real matrix giving the current value of the \nc                       means, muclus(nrec+2,nvar).\nc        ncluster    :  integer giving the number of clusters in the\nc                       data.\nc        psi1        :  real matrix giving the scale matrix for the\nc                       inverted-Wishart component of the baseline\nc                       distribution, psi1(nvar,nvar).\nc        psiinv1     :  real matrix giving the inverse of the scale \nc                       matrix for the inverted-Wishart component of \nc                       the baseline distribution, psiinv1(nvar,nvar).\nc        sigmaclus   :  real matrix giving the current value of the\nc                       variances, sigmaclus(nrec+2,nvar*(nvar+1)/2) .\nc        ss          :  integer vector giving the cluster label for \nc                       each record, ss(nrec).\nc\nc-----------------------------------------------------------------------\nc\nc---- Working space ----------------------------------------------------\nc\nc        ccluster    :  integer vector indicating the number of\nc                       subjects in each cluster, ccluster(nrec).\nc        cstrt       :  integer matrix used to save the cluster\nc                       structure, cstrt(nsave,nsave).\nc        count       :  index.           \nc        detlog      :  real used to save the log-determinant in an\nc                       matrix inversion process.\nc        denom       :  real matrix used to evaluate the conditional\nc                       densities, denom(npred).\nc        dispcount   :  index. \nc        dnrm        :  density of a normal distribution.\nc        evali       :  integer indicator used in updating the state.\nc        fs          :  real vector used to evaluate the conditional\nc                       densities, fs(ngrid).\nc        fm          :  real vector used to evaluate the conditional\nc                       means, fs(npred).\nc        i           :  index. \nc        ii          :  index. \nc        ihmssf      :  integer function to determine the position of a\nc                       half-stored matrix.\nc        iflag       :  integer vector used to evaluate the mvn density,\nc                       iflag(nvar).\nc        iflagx      :  integer vector used to evaluate the mvn density,\nc                       iflagx(nx).\nc        isave       :  index. \nc        iscan       :  index.\nc        j           :  index. \nc        k           :  index. \nc        l           :  index. \nc        l1          :  index. \nc        l2          :  index. \nc        muwork      :  real vector used to save the mean,\nc                       one observation, muwork(nvar).\nc        num         :  real matrix used to evaluate the conditional \nc                       densities, num(npred,ngrid).  \nc        ns          :  integer indicator used in updating the state. \nc        nscan       :  integer indicating the total number of MCMC\nc                       scans.\nc        nuniqs      :  integer giving the dimension of the half-stored\nc                       covariance matrix.\nc        nuwork      :  index.\nc        prob        :  real vector used to update the cluster \nc                       structure, prob(nrec+2).\nc        rgamma      :  gamma random number generator\nc        s1          :  real matrix giving the covariance matrix of \nc                       the normal component of the baseline \nc                       distribution, s1(nvar,nvar).\nc        seed1       :  seed for random number generation.\nc        seed2       :  seed for random number generation.\nc        seed3       :  seed for random number generation.\nc        sigmawork   :  real matrix used to save the variance of\nc                       one observation, sigmawork(nvar,nvar).\nc        sigworkinv  :  real matrix used to save the inverse of the\nc                       variance of one observation, \nc                       sigworkinv(nvar,nvar).\nc        since       :  index.\nc        skipcount   :  index. \nc        theta       :  real vector used to save randomnly generated\nc                       mean vector, theta(nvar).\nc        tmp1        :  real working variable. \nc        tmp2        :  real working variable.\nc        workm1      :  real matrix used to update the cluster \nc                       structure, workm1(nvar,nvar).\nc        workm2      :  real matrix used to update the cluster \nc                       structure, workm2(nvar,nvar).\nc        workm3      :  real matrix used to update the cluster \nc                       structure, workm3(nvar,nvar).\nc        workmx      :  real matrix used to evaluate the\nc                       conditional densities, workmn(nx,nx).\nc        workmh1     :  real vector used to update the cluster\nc                       structure, workmh1(nvar*(nvar+1)/2).\nc        workmh2     :  real vector used to update the cluster\nc                       structure, workmh2(nvar*(nvar+1)/2).\nc        worksam     :  real matrix used to store samples,\nc                       worksam(ngrid).\nc        workv1      :  real vector used to update the cluster\nc                       structure, workv1(nvar).\nc        workv2      :  real vector used to update the cluster\nc                       structure, workv2(nvar).\nc        workv3      :  real vector used to update the cluster\nc                       structure, workv3(nvar).\nc        workvx      :  real vector used to evaluate the\nc                       conditional densities, workvx(nx).\nc        ywork       :  real vector used to save the variables of,\nc                       one observation, ywork(nvar).\nc\nc=======================================================================\n\n      implicit none \n\nc+++++Data\n      integer nrec,nx,nvar,nmissi,nmiss\n      integer missp(nmiss,2)  \n      real*8 z(nrec,nvar)\n      real*8 zsave(nrec,nvar)\n\nc+++++Prediction\n      integer cband,npred,ngrid,tband\n      real*8 xpred(npred,nx)   \n      real*8 grid(ngrid) \n\nc+++++Prior \n      integer nuvec(3),nu1,nu2,m1rand\n      real*8 aa0,ab0,a0b0(2)\n      real*8 psiinv2(nvar,nvar)\n      real*8 tau(2),tau1,tau2\n      real*8 s2inv(nvar,nvar),s2invm2(nvar)\n\nc+++++MCMC parameters\n      integer mcmc(5),nburn,nskip,nsave,ndisplay\n\nc+++++Output\n      real*8 cpo(nrec,2)\n      real*8 thetasave(nsave,nvar+nvar*(nvar+1)/2+3)\n      real*8 denspm(npred,ngrid)\n      real*8 denspl(npred,ngrid)\n      real*8 densph(npred,ngrid)\n      real*8 meanfpm(npred)\n      real*8 meanfpl(npred)\n      real*8 meanfph(npred)\n\nc+++++Current values of the parameters\n      integer ncluster,ss(nrec)\n      real*8 alpha,k0,m1(nvar),muclus(nrec+100,nvar)\n      real*8 psi1(nvar,nvar),psiinv1(nvar,nvar)\n      real*8 sigmaclus(nrec+100,nvar*(nvar+1)/2)\n\nc+++++Seeds\n      integer seed(2),seed1,seed2\n\nc+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nc+++++External working space\nc+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n      integer ccluster(nrec)\n      integer cstrt(nrec,nrec)\n      integer iflag(nvar)\n      integer iflagx(nx)\n      real*8 muwork(nvar),prob(nrec+100)\n      real*8 s1(nvar,nvar)\n      real*8 sigmawork(nvar,nvar),sigworkinv(nvar,nvar)\n      real*8 theta(nvar)\n      real*8 workm1(nvar,nvar),workm2(nvar,nvar),workm3(nvar,nvar)\n      real*8 workmh1(nvar*(nvar+1)/2),workmh2(nvar*(nvar+1)/2)\n      real*8 workv1(nvar),workv2(nvar),workv3(nvar)\n      real*8 ywork(nvar)\n\n      real*8 workvx(nx) \n      real*8 workmx(nx,nx) \n\n      real*8 num(npred,ngrid)\n      real*8 denom(npred) \n      real*8 fs(ngrid) \n      real*8 fm(npred) \n\n      real*8 worksam(nsave) \n\n      real*8 numcpo(nrec),denomcpo(nrec)\n\nc+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nc+++++Internal working space\nc+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nc+++++General\n      integer counter,evali\n      integer i,ii,ihmssf,j,jj,k,l,nuniqs,nuwork,ns,ok \n      integer since,sprint\n      integer isample\n\n      real*8 detlog,detlogx\n      real*8 muc,sigmac  \n      real*8 tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7,tmpm,tmpsd\n      real*8 tpi\n      real*8 cpotest\n      parameter(tpi=6.283185307179586476925286766559d0)\n      \nc+++++MCMC\n      integer dispcount,isave,iscan,nscan,skipcount \n\nc+++++RNG and distributions\n      real*8 dnrm,rnorm,rgamma\n\nc+++++DP (functional parameter)\n      real*8 eps,rbeta,weight\n      parameter(eps=0.01)\n\nc+++++CPU time\n      real*8 sec00,sec0,sec1,sec\n\nc++++ Define parameters\n\n      aa0=a0b0(1)\n      ab0=a0b0(2)\n\n      tau1=tau(1)\n      tau2=tau(2)\n      \n      nburn=mcmc(1)\n      nskip=mcmc(2)\n      ndisplay=mcmc(3)\n      cband=mcmc(4)\n      tband=mcmc(5)\n\n      nuniqs=nvar*(nvar+1)/2\n      nu1=nuvec(1)\n      nu2=nuvec(2)\n      m1rand=nuvec(3)\n\n      cpotest=0.d0\n      \nc++++ opening files\n\n      open(unit=1,file='dppackage1.out',status='unknown',\n     &     form='unformatted')\n\n      open(unit=2,file='dppackage2.out',status='unknown',\n     &     form='unformatted')\n\nc++++ set random number generator\n\n      seed1=seed(1)\n      seed2=seed(2)\n\n      call setall(seed1,seed2)\n\nc++++ cluster structure\n\n      do i=1,nrec\n         ccluster(ss(i))=ccluster(ss(i))+1\n         cstrt(ss(i),ccluster(ss(i)))=i\n      end do\n\nc+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nc++++ start the MCMC algorithm\nc+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n      isample=1\n      isave=0\n      skipcount=0\n      dispcount=0\n      nscan=nburn+(nskip+1)*(nsave)\n\n      call cpu_time(sec0)\n      sec00=0.d0\n      zsave=z\n      \n      do iscan=1,nscan\n\nc+++++++++++++++++++++++++++++++++++++++++\nc+++++++ Imputing the missing data\nc+++++++++++++++++++++++++++++++++++++++++\n         z=zsave\n         if(nmissi.eq.1)then\n\nc++++++++++ check if the user has requested an interrupt\n            call rchkusr()\n\n            do ii=1,nmiss\n\n               i=missp(ii,1)\n               jj=missp(ii,2)   \n\n               do j=1,nvar\n                  muwork(j)=muclus(ss(i),j)\n                  do k=1,nvar\n                     sigmawork(j,k)=sigmaclus(ss(i),ihmssf(j,k,nvar))\n                  end do\n               end do                \n\n               call condmvn(jj,sigmawork,nvar,workm1,workm2)\n               tmp1=sqrt(workm1(1,1))\n\n               do k=1,nvar\n                  tmp2=0.d0\n                  do l=1,nvar\n                     tmp2=tmp2+workm2(k,l)*muwork(l) \n                  end do\n                  workv2(k)=tmp2\n \n                  tmp2=0.d0\n                  do l=1,nvar\n                     tmp2=tmp2+workm2(k,l)*z(i,l) \n                  end do\n                  workv3(k)=tmp1\n               end do\n\n               tmp2=muwork(jj)\n               do k=2,nvar\n                  tmp2=tmp2-workm1(1,k)*(workv3(k)-workv2(k))\n               end do            \n\n               z(i,jj)=rnorm(tmp2,tmp1) \n            end do\n         end if \n\nc+++++++++++++++++++++++++++++++++++++++++\nc+++++++ Sampling for the measurement error distribution\nc+++++++++++++++++++++++++++++++++++++++++\n        \n         do ii=1,nrec\n             do jj=2,nvar\n               tmpm=z(ii,jj)*0.8\n               tmpsd=0.2\n               z(ii,jj)=rnorm(tmpm,tmpsd) \n             end do\n         end do\n         \n\n\nc++++++++++++++++++++++++++++++++++         \nc+++++++ DP part\nc++++++++++++++++++++++++++++++++++\n\nc++++++++++++++++++++++++++++++\nc+++++++ a) configurations \nc++++++++++++++++++++++++++++++\n\nc         call intpr(\"Step 1a\",-1,0,1)\n\n         do i=1,nrec\n\n            ns=ccluster(ss(i))\n            \nc++++++++++ observation in cluster with more than 1 element\n             \n            if(ns.gt.1)then\n \n               ccluster(ss(i))=ccluster(ss(i))-1 \n\n               j=1\n               ok=0\n               do while(ok.eq.0.and.j.le.ns)\n                  if(cstrt(ss(i),j).eq.i)ok=j\n                  j=j+1\n               end do\n\n               do j=ok,ns-1\n                  cstrt(ss(i),j)=cstrt(ss(i),j+1)\n               end do\n\n               isample=1\n            end if\n\nc++++++++++ observation in cluster with only 1 element\n             \n            if(ns.eq.1)then\n                \n               since=ss(i)\n\n               if(since.lt.ncluster)then\n\n                   call relabelddr(i,since,nrec,nvar,ncluster,\n     &                             ccluster,cstrt,ss,muclus,sigmaclus,\n     &                             muwork,sigmawork)                   \n               end if\n\n               ccluster(ncluster)=ccluster(ncluster)-1 \n               ncluster=ncluster-1\n\n               isample=2\n            end if\n\nc++++++++++ sampling\n\n            do j=1,nvar\n               ywork(j)=z(i,j)\n            end do\n               \n            do j=1,ncluster\n               do k=1,nvar\n                  muwork(k)=muclus(j,k)\n                  do l=1,nvar\n                     sigmawork(k,l)=sigmaclus(j,ihmssf(k,l,nvar))\n                  end do\n               end do                \n                   \n               call dmvn(nvar,ywork,muwork,sigmawork,tmp1,\n     &                   workv1,workm1,workm2,workv2,iflag)\n\n               prob(j)=dble(ccluster(j))*exp(tmp1)\n            end do\n            \n            if(isample.eq.1)then\n               \n               do k=1,nvar\n                  do l=1,nvar\n                     workm3(k,l)=psiinv1(k,l)\n                  end do\n               end do\n\n               call riwishart(nvar,nu1,workm3,workm1,workm2,workv1,\n     &                        workmh1,workmh2,iflag)\n\n               do k=1,nvar\n                  do l=1,nvar\n                     s1(k,l)=workm3(k,l)/k0\n                     sigmaclus(ncluster+1,ihmssf(k,l,nvar))=\n     &                      workm3(k,l)\n                  end do\n               end do\n\n               call rmvnorm(nvar,m1,s1,workmh1,workv1,theta) \n   \n               do k=1,nvar\n                  muclus(ncluster+1,k)=theta(k)\n               end do  \n            end if\n\n            do k=1,nvar\n                  muwork(k)=muclus(ncluster+1,k)\n                  do l=1,nvar\n                  sigmawork(k,l)=\n     &                     sigmaclus(ncluster+1,ihmssf(k,l,nvar))\n               end do\n            end do      \n\n            call dmvn(nvar,ywork,muwork,sigmawork,tmp1,\n     &                workv1,workm1,workm2,workv2,iflag)\n                   \n            prob(ncluster+1)=alpha*exp(tmp1)\n               \n            call simdisc(prob,nrec+100,ncluster+1,evali)\n               \n               \n            if(evali.le.ncluster)then\n               ss(i)=evali\n               ccluster(evali)=ccluster(evali)+1\n               cstrt(evali,ccluster(evali))=i\n            end if   \n               \n            if(evali.gt.ncluster)then\n               ncluster=ncluster+1\n               ss(i)=ncluster\n               ccluster(ncluster)=1\n               cstrt(ncluster,ccluster(ncluster))=i\n               do j=1,nvar\n                  muclus(ncluster,j)=muclus(evali,j)\n                  do k=j,nvar\n                     sigmaclus(ncluster,ihmssf(j,k,nvar))=\n     &                         sigmaclus(evali,ihmssf(j,k,nvar))\n                  end do\n               end do\n            end if               \n\n         end do\n\n\nc++++++++++++++++++++++++++++++\nc+++++++ b) Resampling step\nc++++++++++++++++++++++++++++++\n\nc         call intpr(\"Step 1b\",-1,0,1)\n\n         do ii=1,ncluster\n\nc++++++++++ check if the user has requested an interrupt\n            call rchkusr()\n\nc++++++++++ cluster's means and variances\n\n            ns=ccluster(ii)\n\n            do i=1,nvar\n               workv1(i)=m1(i)*(dble(k0)/(dble(k0)+dble(ns)))\n               workv2(i)=0.d0\n            end do\n\n            do i=1,ns\n               do j=1,nvar \n                  workv2(j)=workv2(j)+z(cstrt(ii,i),j)                  \n               end do\n            end do\n\n            do i=1,nvar\n               workv2(i)=workv2(i)/dble(ns)\n               muwork(i)=workv1(i)+workv2(i)*\n     &                  (dble(ns)/(dble(k0)+dble(ns)))\n            end do\n\n            do i=1,nvar\n               do j=1,nvar\n                  workm1(i,j)=0.d0\n                  workm2(i,j)=0.d0\n               end do\n            end do\n\n            do i=1,ns\n               do j=1,nvar \n                  do k=1,nvar \n                     workm1(j,k)=workm1(j,k)+\n     &                     (z(cstrt(ii,i),j)-workv2(j))*                  \n     &                     (z(cstrt(ii,i),k)-workv2(k))\n                  end do   \n               end do\n            end do\n\n            do i=1,nvar\n               do j=1,nvar\n                  workm1(i,j)=workm1(i,j)+psiinv1(i,j)\n               end do\n            end do\n            \n            do i=1,nvar\n               do j=1,nvar\n                  workm2(i,j)=workm2(i,j)+\n     &                       (workv2(i)-m1(i))*                  \n     &                       (workv2(j)-m1(j))\n               end do\n            end do\n            \n            do i=1,nvar\n               do j=1,nvar\n                  workm1(i,j)=workm1(i,j)+workm2(i,j)\n     &                       *(dble(k0*ns)/dble(k0+ns))\n               end do\n            end do\n\n            call riwishart(nvar,nu1+ns,workm1,workm2,workm3,workv1,\n     &                     workmh1,workmh2,iflag)\n\n            do i=1,nvar\n               do j=i,nvar\n                  sigmaclus(ii,ihmssf(i,j,nvar))=workm1(i,j)\n               end do\n            end do            \n\n            do i=1,nvar\n               do j=1,nvar\n                  sigmawork(i,j)=workm1(i,j)/dble(k0+ns)\n               end do\n            end do            \n            \n            call rmvnorm(nvar,muwork,sigmawork,workmh1,workv1,theta) \n            \n            do i=1,nvar\n               muclus(ii,i)=theta(i)\n            end do\n         end do   \n\n\nc++++++++++++++++++++++++++++++++++         \nc+++++++ Baseline distribution\nc++++++++++++++++++++++++++++++++++\n\nc+++++++ check if the user has requested an interrupt\n         call rchkusr()\n\nc+++++++ scale matrix of the inverted-Wishart component\n\nc         call intpr(\"Step 2a\",-1,0,1)\n         \n         if(nu2.gt.0)then\n         \n            do i=1,nvar\n               do j=1,nvar\n                  workm1(i,j)=0.d0\n               end do\n            end do\n\n            do i=1,ncluster\n               do j=1,nvar \n                  do k=1,nvar \n                     sigmawork(j,k)=\n     &                           sigmaclus(i,ihmssf(j,k,nvar))\n                  end do   \n               end do\n            \n               call invdet(sigmawork,nvar,sigworkinv,detlog,iflag,\n     &                     workv3)\n\n               do j=1,nvar \n                  do k=1,nvar \n                     workm1(j,k)=workm1(j,k)+sigworkinv(j,k)\n                  end do   \n               end do\n            end do\n\n            do i=1,nvar\n               do j=1,nvar\n                  workm1(i,j)=workm1(i,j)+psiinv2(i,j)\n               end do\n            end do\n\n            nuwork=nu2+ncluster*nu1\n\n            call riwishart(nvar,nuwork,workm1,workm2,workm3,\n     &                     workv1,workmh1,workmh2,iflag)\n\n            do i=1,nvar\n               do j=1,nvar\n                  psi1(i,j)=workm1(i,j)\n                  psiinv1(i,j)=workm2(i,j)\n               end do\n            end do\n\n         end if\n\nc+++++++ mean of the normal component\n\n         if(m1rand.eq.1)then\n         \n            do i=1,nvar\n               workv1(i)=s2invm2(i)\n               workv2(i)=0.d0\n               do j=1,nvar\n                  workm1(i,j)=0.d0\n               end do\n            end do\n\n            do i=1,ncluster\n         \n               do j=1,nvar \n                  do k=1,nvar \n                     sigmawork(j,k)=\n     &                           sigmaclus(i,ihmssf(j,k,nvar))\n                  end do   \n               end do\n            \n               call invdet(sigmawork,nvar,sigworkinv,detlog,iflag,\n     &                     workv3)\n\n               do j=1,nvar\n                  tmp1=0.d0  \n                  do k=1,nvar \n                     workm1(j,k)=workm1(j,k)+sigworkinv(j,k)\n                     tmp1=tmp1+dble(k0)*sigworkinv(j,k)*muclus(i,k)\n                  end do\n                  workv2(j)=workv2(j)+tmp1\n               end do         \n            end do\n\n            do i=1,nvar\n               do j=1,nvar\n                  workm1(i,j)=workm1(i,j)*k0\n               end do\n            end do\n\n            do i=1,nvar\n               workv1(i)=workv1(i)+workv2(i)\n               do j=1,nvar\n                  sigmawork(i,j)=s2inv(i,j)+workm1(i,j)\n               end do\n            end do\n            \n            call invdet(sigmawork,nvar,sigworkinv,detlog,iflag,workv3)\n\n            do i=1,nvar\n               tmp1=0.d0\n               do j=1,nvar\n                  tmp1=tmp1+sigworkinv(i,j)*workv1(j)    \n                  sigmawork(i,j)=sigworkinv(i,j)\n               end do\n               muwork(i)=tmp1\n            end do\n\n            call rmvnorm(nvar,muwork,sigmawork,workmh1,workv1,theta) \n         \n            do i=1,nvar\n               m1(i)=theta(i)\n            end do\n\n         end if\n\nc+++++++ k0\n\n         if(tau1.gt.0)then\n\n            tmp1=0.d0\n            do i=1,ncluster \n               do j=1,nvar\n                  ywork(j)=muclus(i,j)-m1(j)\n                  do k=1,nvar\n                     sigmawork(j,k)=sigmaclus(i,ihmssf(j,k,nvar))\n                  end do\n               end do\n            \n               call invdet(sigmawork,nvar,sigworkinv,detlog,iflag,\n     &                     workv3)\n\n               do j=1,nvar\n                  do k=1,nvar\n                     tmp1=tmp1+ywork(j)*sigworkinv(j,k)*ywork(k)\n                  end do\n               end do\n            end do   \n         \n            k0=rgamma(0.5d0*(dble(ncluster)+tau1),0.5d0*(tmp1+tau2))\n\n         end if\n\nc++++++++++++++++++++++++++++++++++         \nc+++++++ Precision parameter\nc++++++++++++++++++++++++++++++++++\n\nc         call intpr(\"Step 3\",-1,0,1)\n         \n         if(aa0.gt.0.d0)then\n            call samalph(alpha,aa0,ab0,ncluster,nrec)\n         end if \n\nc++++++++++++++++++++++++++++++++++         \nc+++++++ save samples\nc++++++++++++++++++++++++++++++++++         \n\n         if(iscan.gt.nburn)then\n            skipcount=skipcount+1\n            if(skipcount.gt.nskip)then\n               isave=isave+1\n               dispcount=dispcount+1\n\n               counter=0\n\nc+++++++++++++ normal baseline mean\n\n               do i=1,nvar\n                  counter=counter+1\n                  thetasave(isave,counter)=m1(i)\n               end do   \n\nc+++++++++++++ k0 parameter\n\n               counter=counter+1\n               thetasave(isave,counter)=k0\n\nc+++++++++++++ IW baseline scale\n\n               do i=1,nvar\n                  do j=i,nvar\n                     counter=counter+1\n                     thetasave(isave,counter)=psi1(i,j)\n                  end do\n               end do\n \nc+++++++++++++ cluster information\n               \n               counter=counter+1\n               thetasave(isave,counter)=ncluster\n               counter=counter+1\n               thetasave(isave,counter)=alpha   \n               \nc+++++++++++++ Partially sampling the DP and computing the cond. dist.\n\n               do i=1,ncluster\n                  prob(i)=dble(ccluster(i))/(alpha+dble(nrec))\n               end do\n               prob(ncluster+1)=alpha/(alpha+dble(nrec))\n               call simdisc(prob,nrec+100,ncluster+1,evali)\n\n               if(evali.le.ncluster)then\n                  do i=1,nvar  \n                     muwork(i)=muclus(evali,i)\n                     do j=1,nvar\n                        sigmawork(i,j)=sigmaclus(evali,\n     &                                 ihmssf(i,j,nvar))\n                     end do\n                  end do  \n               end if\n               if(evali.eq.ncluster+1)then \n                  do k=1,nvar\n                     do l=1,nvar\n                        workm3(k,l)=psiinv1(k,l)\n                     end do\n                  end do\n\n                  call riwishart(nvar,nu1,workm3,workm1,workm2,\n     &                           workv1,workmh1,workmh2,iflag)\n                  do k=1,nvar\n                     do l=1,nvar\n                        s1(k,l)=workm3(k,l)/dble(k0)\n                        sigmawork(k,l)=workm3(k,l)\n                     end do\n                  end do\n                  call rmvnorm(nvar,m1,s1,workmh1,workv1,theta) \n                  do k=1,nvar\n                     muwork(k)=theta(k)\n                  end do      \n               end if\n\n               do i=2,nvar\n                  workvx(i-1)=muwork(i)\n                  do j=2,nvar\n                     workmx(i-1,j-1)=sigmawork(i,j)         \n                  end do  \n               end do   \n               call inversedet(workmx,nx,iflagx,detlogx)\n\n               call condmvn(1,sigmawork,nvar,workm1,workm2)\n               sigmac=sqrt(workm1(1,1))\n\n               tmp1=rbeta(1.d0,alpha+dble(nrec))\n               tmp2=tmp1\n               weight=(1.d0-tmp1)\n\n               do i=1,npred  \n                  call rchkusr()\n                  muc=muwork(1)\n                  do k=2,nvar\n                     muc=muc-workm1(1,k)*(xpred(i,k-1)-muwork(k))\n                  end do            \n\n                  tmp4=-(dble(nx)*log(tpi))\n                  tmp5=0.d0  \n                  do j=1,nx\n                     do k=1,nx\n                        tmp5=tmp5+(xpred(i,j)-workvx(j))*\n     &                       workmx(j,k)*(xpred(i,k)-workvx(k))\n                     end do\n                  end do\n                  tmp6=(tmp4-detlogx-tmp5)/2.d0\n                  tmp7=exp(tmp6)\n                  \n                  do j=1,ngrid  \n                     num(i,j)=tmp1*dnrm(grid(j),muc,sigmac,0,0)*tmp7\n                  end do \n                  denom(i)=tmp1*tmp7\n                  fm(i)=tmp1*tmp7*muc\n               end do\n\n               do while((1.d0-tmp2).gt.eps)\n                  call rchkusr()\n\n                  tmp3=rbeta(1.d0,alpha+dble(nrec))\n                  tmp1=weight*tmp3\n                  weight=weight*(1.d0-tmp3)\n\n                  call simdisc(prob,nrec+2,ncluster+1,evali)\n\n                  if(evali.le.ncluster)then\n                     do i=1,nvar  \n                        muwork(i)=muclus(evali,i)\n                        do j=1,nvar\n                           sigmawork(i,j)=sigmaclus(evali,\n     &                                              ihmssf(i,j,nvar))\n                        end do\n                     end do  \n                  end if\n\n                  if(evali.eq.ncluster+1)then \n                     do k=1,nvar\n                        do l=1,nvar\n                           workm3(k,l)=psiinv1(k,l)\n                        end do\n                     end do\n\n                     call riwishart(nvar,nu1,workm3,workm1,workm2,\n     &                              workv1,workmh1,workmh2,iflag)\n\n                     do k=1,nvar\n                        do l=1,nvar\n                           s1(k,l)=workm3(k,l)/dble(k0)\n                           sigmawork(k,l)=workm3(k,l)\n                        end do\n                     end do\n                     call rmvnorm(nvar,m1,s1,workmh1,workv1,theta) \n                     do k=1,nvar\n                        muwork(k)=theta(k)\n                     end do      \n                  end if\n\n                  do i=2,nvar\n                     workvx(i-1)=muwork(i)\n                     do j=2,nvar\n                        workmx(i-1,j-1)=sigmawork(i,j)         \n                     end do  \n                  end do   \n                  call inversedet(workmx,nx,iflagx,detlogx)\n\n                  call condmvn(1,sigmawork,nvar,workm1,workm2)\n                  sigmac=sqrt(workm1(1,1))\n\n                  do i=1,npred  \n                     call rchkusr()\n                     muc=muwork(1)\n                     do k=2,nvar\n                        muc=muc-workm1(1,k)*(xpred(i,k-1)-muwork(k))\n                     end do            \n\n                     tmp4=-(dble(nx)*log(tpi))\n                     tmp5=0.d0  \n                     do j=1,nx\n                        do k=1,nx\n                           tmp5=tmp5+(xpred(i,j)-workvx(j))*\n     &                       workmx(j,k)*(xpred(i,k)-workvx(k))\n                        end do\n                     end do\n                     tmp6=(tmp4-detlogx-tmp5)/2.d0\n                     tmp7=exp(tmp6)\n\n                     do j=1,ngrid  \n                        num(i,j)=num(i,j)+\n     &                           tmp1*dnrm(grid(j),muc,sigmac,0,0)*tmp7\n                     end do \n                     denom(i)=denom(i)+tmp1*tmp7\n                     fm(i)=fm(i)+tmp1*tmp7*muc\n                 end do\n\n                  tmp2=tmp2+tmp1\n               end do\n\n               do i=1,npred\n                  call rchkusr()\n\n                  fm(i)=fm(i)/denom(i)\n                  meanfpm(i)=meanfpm(i)+fm(i) \n                  do j=1,ngrid\n                     fs(j)=num(i,j)/denom(i)\n                     denspm(i,j)=denspm(i,j)+fs(j)\n                  end do\n                  write(1) (fs(j),j=1,ngrid)\n               end do \n               write(2) (fm(j),j=1,npred)\n \nc+++++++++++++ cpo\n\n               do i=1,ncluster\n                  prob(i)=dble(ccluster(i))/(alpha+dble(nrec))\n               end do\n               do i=ncluster+1,ncluster+100\n                  prob(i)=alpha/(100.d0*(alpha+dble(nrec)))\n               end do   \n               call simdisc(prob,nrec+100,ncluster+100,evali)\n\n               do i=ncluster+1,ncluster+100\n                  do k=1,nvar\n                     do l=1,nvar\n                        workm3(k,l)=psiinv1(k,l)\n                     end do\n                  end do\n\n                  call riwishart(nvar,nu1,workm3,workm1,workm2,\n     &                           workv1,workmh1,workmh2,iflag)\n                  do k=1,nvar\n                     do l=1,nvar\n                        s1(k,l)=workm3(k,l)/dble(k0)\n                        sigmaclus(i,ihmssf(k,l,nvar))=workm3(k,l)\n                     end do\n                  end do\n                  call rmvnorm(nvar,m1,s1,workmh1,workv1,theta) \n                  do k=1,nvar\n                     muclus(i,k)=theta(k)\n                  end do      \n               end do\n\n               do i=1,nrec\n                  numcpo(i)=0.d0\n                  denomcpo(i)=0.d0\n               end do   \n\n               do ii=1,ncluster+100\n     \n                  do j=1,nvar\n                     muwork(j)=muclus(ii,j)\n                     do k=1,nvar\n                        sigmawork(j,k)=\n     &                         sigmaclus(ii,ihmssf(j,k,nvar))\n                     end do\n                  end do                \n\n                  do j=2,nvar\n                     workvx(j-1)=muwork(j)\n                     do k=2,nvar\n                        workmx(j-1,k-1)=sigmawork(j,k)         \n                     end do  \n                  end do   \n                  call inversedet(workmx,nx,iflagx,detlogx)\n\n                  call condmvn(1,sigmawork,nvar,workm1,workm2)\n                  sigmac=sqrt(workm1(1,1))\n\n                  do i=1,nrec    \n                     call rchkusr()\n                     muc=muwork(1)\n                     do k=2,nvar\n                        muc=muc-workm1(1,k)*(z(i,k)-muwork(k))\n                     end do            \n\n                     tmp4=-(dble(nx)*log(tpi))\n                     tmp5=0.d0  \n                     do j=1,nx\n                        do k=1,nx\n                           tmp5=tmp5+(z(i,j+1)-workvx(j))*\n     &                       workmx(j,k)*(z(i,k+1)-workvx(k))\n                        end do\n                     end do\n                     tmp6=(tmp4-detlogx-tmp5)/2.d0\n                     tmp7=exp(tmp6)\n\n                     numcpo(i)=numcpo(i)+\n     &                   prob(ii)*dnrm(z(i,1),muc,sigmac,0,0)*tmp7\n                     denomcpo(i)=denomcpo(i)+prob(ii)*tmp7\n                     \n                  end do\n               end do\n                \n               tmp2=0.d0\n               do i=1,nrec\n                  tmp3=numcpo(i)/denomcpo(i)\n                  cpo(i,1)=cpo(i,1)+1.0d0/tmp3  \n                  cpo(i,2)=cpo(i,2)+tmp3                   \n\n                  tmp2=tmp2+log(dble(isave)/cpo(i,1))\n               end do\n\nc               call dblepr(\"LPML\",-1,tmp2,1)\n\nc+++++++++++++ print\n               skipcount = 0\n               if(dispcount.ge.ndisplay)then\n                  call cpu_time(sec1)\n                  sec00=sec00+(sec1-sec0)\n                  sec=sec00\n                  sec0=sec1\n                  tmp1=sprint(isave,nsave,sec)\n                  dispcount=0\n               end if   \n            end if\n         end if   \n      end do \n\n      do i=1,nrec\n         call rchkusr()\n         cpo(i,1)=dble(nsave)/cpo(i,1)\n         cpo(i,2)=cpo(i,2)/dble(nsave)\n      end do\n \n      do i=1,npred\n         call rchkusr()\n\n         meanfpm(i)=meanfpm(i)/dble(nsave)\n         do j=1,ngrid\n            denspm(i,j)= denspm(i,j)/dble(nsave)\n         end do\n      end do\n\n      close(unit=1)\n      close(unit=2)\n\n      if(cband.eq.1)then\n\n         call hpddensreg(nsave,npred,ngrid,0.05d0,tband,\n     &                   worksam,fs,denspl,densph)\n\n         call hpddensregmf(nsave,npred,0.05d0,tband,\n     &                     worksam,meanfpl,meanfph)\n      end if\n\n      return\n      end\n\n\nc=======================================================================      \n      subroutine hpddensregmf(nsave,npred,alpha,tint,\n     &                        worksam,llower,lupper)\nc=======================================================================\nc     Compute CI for the conditional means.\nc\nc     Alejandro Jara, 2007-2008\nc=======================================================================\n      implicit none \n\nc+++++External parameters\n      integer tint\n      integer nsave,npred\n      real*8 alpha\n\nc+++++External working\n      real*8 worksam(nsave)\n\nc+++++Output      \n      real*8 llower(npred)\n      real*8 lupper(npred)\n\nc+++++Internal working\n      integer maxnsave,maxnpred\n      parameter(maxnsave=30000,maxnpred=500)\n      real*8 aupp(2),alow(2)\n      real*8 workm(maxnsave,maxnpred)\n\nc+++++Internal working\n      integer i,ii,j   \n\nc+++++algorithm\n\n      if(maxnsave.lt.nsave)then\n         call rexit(\"Increase 'maxnsave' in 'hpddensreg'\")\n      end if   \n\n      if(maxnpred.lt.npred)then\n         call rexit(\"Increase 'maxnpred' in 'hpddensreg'\")\n      end if   \n\n      open(unit=2,file='dppackage2.out',status='old',\n     &     form='unformatted')\n\n      do i=1,nsave\n         read(2) (workm(i,j),j=1,npred)\n      end do\n\n      do ii=1,npred\n         do i=1,nsave \n            call rchkusr()\n            worksam(i)=workm(i,ii)\n         end do  \n          \n         call hpd(nsave,alpha,worksam,alow,aupp)\n          \n         if(tint.eq.1)then\nc               (alow(1),aupp(1)): 100(1-alpha)% HPD interval\nc \n            llower(ii)=alow(1)\n            lupper(ii)=aupp(1)\n\n           else\nc              (alow(2),aupp(2)): 100(1-alpha)% Bayesian credible \nc              interval\n\n            llower(ii)=alow(2)\n            lupper(ii)=aupp(2)\n         end if\n\n      end do\n\n      close(unit=2)      \n      return\n      end\n\nc=======================================================================      \n      subroutine hpddensreg(nsave,npred,ngrid,alpha,tint,\n     &                      workv1,fs,llower,lupper)\nc=======================================================================\nc     Compute CI for the conditional densities.\nc\nc     Alejandro Jara, 2007-2008\nc=======================================================================\n      implicit none \nc+++++External parameters\n      integer tint\n      integer nsave,npred,ngrid \n      real*8 alpha\n\nc+++++External working\n      real*8 fs(ngrid)\n      real*8 workv1(nsave)\n\nc+++++Output      \n      real*8 llower(npred,ngrid)\n      real*8 lupper(npred,ngrid)\n\nc+++++Internal parameters\n      integer maxnsave,maxngrid\n      parameter(maxnsave=30000,maxngrid=500)\n      real*8 aupp(2),alow(2)\n      real*8 workm(maxnsave,maxngrid)\n\nc+++++Internal working\n      integer i,ii,j,l   \n\nc+++++algorithm\n\n      if(maxnsave.lt.nsave)then\n         call rexit(\"Increase 'maxnsave' in 'hpddensreg'\")\n      end if   \n\n      if(maxngrid.lt.ngrid)then\n         call rexit(\"Increase 'maxngrid' in 'hpddensreg'\")\n      end if   \n\n      open(unit=1,file='dppackage1.out',status='old',\n     &     form='unformatted')\n\n      do ii=1,npred\n         do i=1,nsave \n            call rchkusr()\n            do j=1,npred\n               read(1) (fs(l),l=1,ngrid)\n               if(ii.eq.j)then\n                  do l=1,ngrid\n                     workm(i,l)=fs(l) \n                  end do\n               end if\n            end do\n          end do  \n          rewind(unit=1)\n          \n          do i=1,ngrid\n             do j=1,nsave\n                workv1(j)=workm(j,i) \n             end do\n          \n             call hpd(nsave,alpha,workv1,alow,aupp)\n          \n             if(tint.eq.1)then\nc               (alow(1),aupp(1)): 100(1-alpha)% HPD interval\nc \n                llower(ii,i)=alow(1)\n                lupper(ii,i)=aupp(1)\n\n              else\nc              (alow(2),aupp(2)): 100(1-alpha)% Bayesian credible \nc              interval\n\n                llower(ii,i)=alow(2)\n                lupper(ii,i)=aupp(2)\n             end if\n\n          end do\n\n      end do      \n\n      close(unit=1)      \n      return\n      end\n\n\nc=======================================================================      \n      subroutine relabelddr(ind,since,nrec,nvar,ncluster,ccluster,cstrt,\n     &                      ss,muclus,sigmaclus,muwork,sigmawork)\nc=======================================================================\nc     relabel the clusters after the elimination of one of them\nc     A.J.V., 2006\n      implicit none\n      integer dimen,i,ihmssf,j\n      integer ind,since,nrec,nvar,ncluster,ccluster(nrec)\n      integer cstrt(nrec,nrec)\n      integer ss(nrec)\n      real*8 muclus(nrec+100,nvar),sigmaclus(nrec+100,nvar*(nvar+1)/2)\n      real*8 muwork(nvar),sigmawork(nvar,nvar)\n\n      integer ns,ii  \n      dimen=nvar*(nvar+1)/2\n\n      do i=1,nvar\n         muwork(i)=muclus(since,i)\n         do j=1,nvar\n            sigmawork(i,j)=sigmaclus(since,ihmssf(i,j,nvar))\n         end do\n      end do\n      \n      do i=since+1,ncluster\n\n         ns=ccluster(i)    \n         \n         do j=1,ns\nc++++++++++ check if the user has requested an interrupt\n            call rchkusr()\n            ii=cstrt(i,j) \n            ss(ii)=i-1\n         end do\n\n         do j=1,ns\n            cstrt(i-1,j)=cstrt(i,j) \n         end do\n\n         do j=1,nvar\n            muclus(i-1,j)=muclus(i,j)\n         end do\n         do j=1,dimen\n            sigmaclus(i-1,j)=sigmaclus(i,j)\n         end do\n         \n         ccluster(i-1)=ccluster(i)\n      end do\n      \n      ss(ind)=ncluster\n      \n      do i=1,nvar\n         muclus(ncluster,i)=muwork(i)\n         do j=i,nvar\n             sigmaclus(ncluster,ihmssf(i,j,nvar))=sigmawork(i,j)\n         end do\n      end do\n      \n      ccluster(ncluster)=1\n      \n      return\n      end  \n            \n",
    "created" : 1491565195930.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3649412510",
    "id" : "FD76CCF6",
    "lastKnownWriteTime" : 1491570284,
    "last_content_update" : 1491570342471,
    "path" : "G:/STAFF/Michael Sachs/R projects/DPpackagemod/src/DPdensityreg.f",
    "project_path" : "src/DPdensityreg.f",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "text"
}