{
    "collab_server" : "",
    "contents" : "### DPcdencity.R                   \n### Fit a Dirichlet Process Mixture of Normals model for conditional density\n### estimation.\n###\n### Copyright: Alejandro Jara, 2008-2012.\n###\n### Last modification: 27-08-2010.\n###\n### This program is free software; you can redistribute it and/or modify\n### it under the terms of the GNU General Public License as published by\n### the Free Software Foundation; either version 2 of the License, or (at\n### your option) any later version.\n###\n### This program is distributed in the hope that it will be useful, but\n### WITHOUT ANY WARRANTY; without even the implied warranty of\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n### General Public License for more details.\n###\n### You should have received a copy of the GNU General Public License\n### along with this program; if not, write to the Free Software\n### Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n###\n### The author's contact information:\n###\n###      Alejandro Jara\n###      Department of Statistics\n###      Facultad de Matematicas\n###      Pontificia Universidad Catolica de Chile\n###      Casilla 306, Correo 22 \n###      Santiago\n###      Chile\n###      Voice: +56-2-3544506  URL  : http://www.mat.puc.cl/~ajara\n###      Fax  : +56-2-3547729  Email: atjara@uc.cl\n###\n\n\n\"DPcdensity\"<-\nfunction(y,x,xpred,ngrid=100,grid=NULL,compute.band=FALSE,type.band=\"PD\",prior,mcmc,state,status,data=sys.frame(sys.parent()),work.dir=NULL,measerr=1)\nUseMethod(\"DPcdensity\")\n\nDPcdensity.default<-\nfunction(y,\n         x,\n         xpred,\n         ngrid=100,\n\t\t grid=NULL,\n\t\t compute.band=FALSE,\n\t\t type.band=\"PD\",\n         prior,\n         mcmc,\n         state,\n         status,\n         data=sys.frame(sys.parent()),\n         work.dir=NULL,measerr=1)\n{\n       #########################################################################################\n       # call parameters\n       #########################################################################################\n         cl <- match.call()\n\n       #########################################################################################\n       # response\n       #########################################################################################\n         nrec <- length(y)\n          \n       #########################################################################################\n       # add covariates to the data matrix\n       #########################################################################################\n         x <- as.matrix(x)\n         nx <- dim(x)[2]\n         z <- cbind(y,x)\n         nvar <- nx + 1  \n\n       #########################################################################################\n       # identify missing values to be imputed\n       #########################################################################################\n         nmiss <- sum(is.na(z))\n         nmissi <- 1\n         missp <- NULL\n         for(i in 1:nrec)\n         {\n             nmi <- sum(is.na(z[i,]))\n             nmi2 <- seq(1,nvar)[is.na(z[i,])] \n             if(nmi>0)\n             {\n                for(j in 1:nmi)\n                { \n                    missp <- rbind(missp,c(i,nmi2[j]))  \n                }\n             }  \n         }\n         \n         if(nmiss==0)\n         {\n            nmissi <- 0\n            nmiss <- 1\n            missp <- matrix(0,nrow=nmiss,2)\n         }\n\n       #########################################################################################\n       # change working directory (if requested..)\n       #########################################################################################\n         if(!is.null(work.dir))\n         {\n            cat(\"\\n Changing working directory to \",work.dir,\"\\n\")\n            old.dir <- getwd()  # by default work in current working directory\n            setwd(work.dir)\n         }\n\n       #########################################################################################\n       # prediction\n       #########################################################################################\n         xpred <- as.matrix(xpred)\n         npred <- nrow(xpred)\n         pz <- ncol(xpred)  \n\n         if(pz != nx)\n         {\n            cat(\"\\n *** Error: ncol(xpred) != ncol(x). Need to match.\\n\")\n            return(-1)\n         }\n \n\t\t if(is.null(grid))\n\t\t { \n\t\t\tyy <- na.omit(y)  \n\t\t\tminy <- min(yy)\n\t\t\tmaxy <- max(yy)\n\t\t\tvary <- var(yy)\n\t\t\tgrid <- seq(from=miny-0.25*sqrt(vary),to=maxy+0.25*sqrt(vary),length.out=ngrid)\n\t\t }\n\t\t else\n\t\t {\n\t\t\tgrid <- as.vector(grid)\n\t\t\tngrid <- length(grid)\n\t\t }\n\n\t\t cband <- 0\n\t\t if(compute.band)\n\t\t {\n\t\t\tcband <- 1\n\t\t }\n\t\t\t\n\t\t tband <- 1\n\t\t if(type.band!=\"HPD\")\n\t\t {\n\t\t\ttband <- 2\n\t\t }\n\n\n       #########################################################################################\n       # prior information\n       #########################################################################################\n\n         if(is.null(prior$a0))      \n\t\t {\n            a0 <--1\n\t\t\tb0 <--1 \n            alpha<-prior$alpha\n            alpharand<-0\n         }\n         else\n         {\n            a0 <- prior$a0\n            b0 <- prior$b0\n\t\t\talpha <- 1\n\t\t\talpharand <- 1\n\t\t }\n         a0b0 <- c(a0,b0)\n  \t \n\t\t if(is.null(prior$nu2))\n\t\t {\n            psiinv1 <- matrix(prior$psiinv1,nvar,nvar)\n            psiinv2 <- psiinv1\n            psi1 <- matrix(solve(psiinv1),nvar,nvar)\n            nuvec <- c(prior$nu1,-1)\n            psi1rand <- 0\n\t\t }\n\t\t else\n\t\t {\n\t\t\tpsiinv1 <- matrix(var(z),nvar,nvar)\n            psi1 <- matrix(solve(psiinv1),nvar,nvar)\n            psiinv2 <- matrix(prior$psiinv2,nvar,nvar)\n\t\t\tnuvec <- c(prior$nu1,prior$nu2)\n\t\t\tpsi1rand <- 1\n\t\t }\n  \t \n\t\tif(is.null(prior$m2) && is.null(prior$s2))\n\t\t{\n\t\t\ts2inv <- matrix(0,nrow=nvar,ncol=nvar) \n\t\t\ts2invm2 <- matrix(0,nrow=nvar,ncol=1)\n\t\t\tm1 <- prior$m1\n\t\t\tm1rand <- 0\n\t\t}\n\t\telse\n\t\t{\n            s2inv <- solve(prior$s2)\n            s2invm2 <- s2inv%*%prior$m2\n\t\t\tm1 <- rep(0,nvar)\n            for(i in 1:nvar)\n      \t    {\n                m1[i] <- mean(z[,i])+rnorm(1,0,100)\n       \t    }\n            m1rand <- 1\n         }     \n\n         if(is.null(prior$tau1) && is.null(prior$tau2)) \n         {\n            tau <- c(-2,-2)\n            k0 <- prior$k0\n            k0rand <- 0\n         }\n         else\n         {\n            tau <- c(prior$tau1,prior$tau2)\n            k0 <- rgamma(1,shape=prior$tau1,scale=prior$tau2)\n            k0rand <- 1\n         }\n\n       #########################################################################################\n       # mcmc specification\n       #########################################################################################\n         mcmcvec <- c(mcmc$nburn,mcmc$nskip,mcmc$ndisplay,cband,tband)\n         nsave <- mcmc$nsave\n\n       #########################################################################################\n       # output\n       #########################################################################################\n         cpo <- matrix(0,nrow=nrec,ncol=2) \n         thetasave <- matrix(0,nrow=nsave,ncol=nvar+nvar*(nvar+1)/2+3)\n         denspm <- matrix(0,nrow=npred,ncol=ngrid)\n         denspl <- matrix(0,nrow=npred,ncol=ngrid)\n         densph <- matrix(0,nrow=npred,ncol=ngrid)\n\n         meanfpm <-rep(0,npred) \n         meanfpl <-rep(0,npred) \n         meanfph <-rep(0,npred) \n\n       #########################################################################################\n       # parameters depending on status\n       #########################################################################################\n         nuniq <- nvar*(nvar+1)/2\n\n         if(status==TRUE)\n\t\t {\n            muclus <- matrix(0,nrow=nrec+100,ncol=nvar)\n            sigmaclus <- matrix(0,nrow=nrec+100,ncol=nuniq)\n            for(i in 1:1)\n            {\n                counter <- 0\n                for(j in 1:nvar)\n                {\n                    muclus[i,j] <- m1[j]\n                    for(k in j:nvar)\n                    {\n          \t\tcounter<-counter+1\n          \t\tsigmaclus[i,counter]<-psiinv1[j,k]\n                    }\n                }\n             }\n             ncluster <- 1\n             ss <- rep(1,nrec)\n\t\t }\n\t \n      \t if(status==FALSE)\n\t\t {\n\t\t\talpha <- state$alpha\n            m1 <- state$m1\n            muclus <- state$muclus \n\t\t\tncluster <- state$ncluster\n\t\t\tpsi1 <- state$psi1\n\t\t\tpsiinv1 <- solve(psi1)\n\t\t\tk0 <- state$k0\n\t\t\tsigmaclus <- state$sigmaclus \n\t\t\tss <- state$ss\n            if(nmissi==1) z <- state$z\n\t\t }    \n\n       #########################################################################################\n       # working space\n       #########################################################################################\n         ccluster <- rep(0,nrec)\n         cstrt <- matrix(0,nrow=nrec,ncol=nrec) \n         num <- matrix(0,nrow=npred,ncol=ngrid)\n         denom <- rep(0,npred)  \n         iflag <- rep(0,nvar) \n         muwork <- rep(0,nvar) \n         muwork2 <- rep(0,nvar) \n         prob <- rep(0,(nrec+100))\n         s1 <- matrix(0,nvar,nvar)\n         seed1 <- sample(1:29000,1)\n         seed2 <- sample(1:29000,1)\n         seed <- c(seed1,seed2)\n         sigmawork <- matrix(0,nrow=nvar,ncol=nvar)\n         sigmawork2 <- matrix(0,nrow=nvar,ncol=nvar)\n         sigworkinv <- matrix(0,nrow=nvar,ncol=nvar)\n         theta <- rep(0,nvar)\n         workm1 <- matrix(0,nrow=nvar,ncol=nvar)\n         workm2 <- matrix(0,nrow=nvar,ncol=nvar)\n         workm3 <- matrix(0,nrow=nvar,ncol=nvar)\n         workmh1 <- rep(0,nvar*(nvar+1)/2) \n         workmh2 <- rep(0,nvar*(nvar+1)/2) \n         workv1 <- rep(0,nvar) \n         workv2 <- rep(0,nvar) \n         workv3 <- rep(0,nvar) \n\t\t ywork <- rep(0,nvar)\n\n         iflagx <- rep(0,nx)\n         workvx <- rep(0,nx) \n         workmx <- matrix(0,nrow=nx,ncol=nx) \n\n         fs <- rep(0,ngrid) \n         fm <- rep(0,npred) \n\n         worksam <- rep(0,nsave) \n\n         \n         numcpo <- rep(0,nrec)\n         denomcpo <- rep(0,nrec)\n         \n         nuvec <- c(nuvec,m1rand)\n\n       #########################################################################################\n       # calling the fortran code\n       #########################################################################################\n\n\n         foo <- .Fortran(\"dpdenregr\",\n\t\t\t\tnrec       =as.integer(nrec),\n                nx         =as.integer(nx),\n\t\t\t\tnvar       =as.integer(nvar),\n\t\t\t\tnmissi     =as.integer(nmissi),\n\t\t\t\tnmiss      =as.integer(nmiss),\n\t\t\t\tz          =as.double(z),\n\t\t\t\tmissp      =as.integer(missp),\n\t\t\t\tnpred      =as.integer(npred),\n\t\t\t\txpred      =as.double(xpred),\n\t\t\t\tngrid      =as.integer(ngrid),\n\t\t\t\tgrid       =as.double(grid),\n\t\t\t\ta0b0       =as.double(a0b0),\n\t\t\t\tk0         =as.double(k0),\n\t\t\t\tnuvec      =as.integer(nuvec),\n\t\t\t\ts2inv      =as.double(s2inv),\n\t\t\t\ts2invm2    =as.double(s2invm2),\n\t\t\t\tpsiinv2    =as.double(psiinv2),\n\t\t\t\ttau        =as.double(tau),\n\t\t\t\tmcmc       =as.integer(mcmcvec),\n\t\t\t\tnsave      =as.integer(nsave),\n\t\t\t\tcpo        =as.double(cpo),\n\t\t\t\tthetasave  =as.double(thetasave),\n\t\t\t\tdenspm     =as.double(denspm),\n\t\t\t\tdenspl     =as.double(denspl),\n\t\t\t\tdensph     =as.double(densph),\n\t\t\t\tmeanfpm    =as.double(meanfpm),\n\t\t\t\tmeanfpl    =as.double(meanfpl),\n\t\t\t\tmeanfph    =as.double(meanfph),\n\t\t\t\talpha      =as.double(alpha),\t\t\n\t\t\t\tm1         =as.double(m1),\t\t\n                muclus     =as.double(muclus),\t\t \t\t\n\t\t\t\tncluster   =as.integer(ncluster),\n\t\t\t\tpsi1       =as.double(psi1),\n\t\t\t\tpsiinv1    =as.double(psiinv1),\n\t\t\t\ts1         =as.double(s1),\n\t\t\t\tsigmaclus  =as.double(sigmaclus),\n\t\t\t\tss         =as.integer(ss),\n\t\t\t\tccluster   =as.integer(ccluster),\n                cstrt      =as.integer(cstrt), \n\t\t\t\tiflag      =as.integer(iflag),\n\t\t\t\tnum        =as.double(num),\n\t\t\t\tdenom      =as.double(denom),\n\t\t\t\tfs         =as.double(fs),\n\t\t\t\tfm         =as.double(fm),\n\t\t\t\tmuwork     =as.double(muwork),\n\t\t\t\tprob       =as.double(prob),\n\t\t\t\tseed       =as.integer(seed),\n\t\t\t\tsigmawork  =as.double(sigmawork),\n\t\t\t\tsigworkinv =as.double(sigworkinv),\n\t\t\t\ttheta      =as.double(theta),\n\t\t\t\tworkm1     =as.double(workm1),\n\t\t\t\tworkm2     =as.double(workm2),\n\t\t\t\tworkm3     =as.double(workm3),\n\t\t\t\tworkmh1    =as.double(workmh1),\n\t\t\t\tworkmh2    =as.double(workmh2),\n\t\t\t\tworkv1     =as.double(workv1),\n\t\t\t\tworkv2     =as.double(workv2),\n\t\t\t\tworkv3     =as.double(workv3),\n\t\t\t\tywork      =as.double(ywork),\n\t\t\t\tiflagx     =as.integer(iflagx),\n\t\t\t\tworkvx     =as.double(workvx),\n\t\t\t\tworkmx     =as.double(workmx),\n\t\t\t\tworksam    =as.double(worksam),\n\t\t\t\tnumcpo     =as.double(numcpo),\n\t\t\t\tdenomcpo   =as.double(denomcpo),\n\t\t\t\tPACKAGE    =\"DPpackage\")\n\n       #########################################################################################\n       # save state\n       #########################################################################################\n\n         model.name <- \"Bayesian Semiparametric Density Regression\"\t\t\n\n         cpom<-matrix(foo$cpo,nrow=nrec,ncol=2)         \n         cpo<-cpom[,1]         \n         fso<-cpom[,2]\n       \n         varnames <- colnames(as.matrix(x))\n         if(is.null(varnames))\n         {\n            varnames<-all.vars(cl)[2]\n         }\n         varnames <- c(\"y\",varnames)\n\t\n         state <- list(\n                  alpha=foo$alpha,\n                  m1=matrix(foo$m1,nrow=nvar,ncol=1),\n                  muclus=matrix(foo$muclus,nrow=nrec+100,ncol=nvar),\n                  ncluster=foo$ncluster,\n                  psi1=matrix(foo$psi1,nrow=nvar,ncol=nvar),\n                  k0=foo$k0,\n                  sigmaclus=matrix(foo$sigmaclus,nrow=nrec+100,ncol=nuniq),\n                  ss=foo$ss,\n                  z=matrix(foo$z,nrow=nrec,ncol=nvar) \n                  )\n\n         pnames1 <- NULL\n         for(i in 1:nvar)\n\t\t {\n\t\t\tpnames1 <- c(pnames1,paste(\"m1\",varnames[i],sep=\":\"))\n\t\t }\n         pnames2 <- \"k0\"\n       \n         pnames3 <- NULL\n\t\t for(i in 1:nvar)\n\t\t {\n\t\t\tfor(j in i:nvar)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t{\n\t\t\t\t\ttmp<-varnames[i]\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp <- paste(varnames[i],varnames[j],sep=\"-\")\n\t\t\t\t}   \n\t\t\t\tpnames3 <- c(pnames3,paste(\"psi1\",tmp,sep=\":\"))\n\t\t\t}\t\n\t\t }\n\n         pnames4 <- c(\"ncluster\",\"alpha\")\n         pnames <- c(pnames1,pnames2,pnames3,pnames4)\n\n         thetasave <- matrix(foo$thetasave,nrow=nsave,ncol=nvar+nvar*(nvar+1)/2+3)\n\n         densp.m <- matrix(foo$denspm,nrow=npred,ncol=ngrid)\n         densp.l <- matrix(foo$denspl,nrow=npred,ncol=ngrid)\n         densp.h <- matrix(foo$densph,nrow=npred,ncol=ngrid)\n\n         meanfp.m <- foo$meanfpm\n         meanfp.l <- foo$meanfpl\n         meanfp.h <- foo$meanfph\n\n         colnames(thetasave) <- pnames \n\n         coeff <- apply(thetasave,2,mean)\n \n         save.state <- list(thetasave=thetasave) \n \n         z <- list(call=cl,\n                   y=y,\n                   coefficients=coeff,\n                   varnames=varnames,\n                   modelname=model.name,\n                   cpo=cpo,\n                   fso=fso,  \n                   prior=prior,\n                   mcmc=mcmc,\n                   state=state,\n                   save.state=save.state,\n                   nrec=foo$nrec,\n                   nvar=foo$nvar,\n                   alpharand=alpharand,\n                   psi1rand=psi1rand,\n                   m1rand=m1rand,\n                   k0rand=k0rand,\n                   densp.m=densp.m,\n                   densp.l=densp.l,\n                   densp.h=densp.h,\n                   meanfp.m=meanfp.m,\n                   meanfp.l=meanfp.l,\n                   meanfp.h=meanfp.h,\n                   npred=npred,\n                   ngrid=ngrid,\n                   grid=grid,\n                   compute.band=compute.band)\n                 \n         cat(\"\\n\\n\")\n         class(z)<-\"DPcdensity\"\n  \t return(z)\n}\n\n\n###                    \n### Tools\n###\n### Copyright: Alejandro Jara, 2008\n### Last modification: 25-05-2008.\n###\n\n\"print.DPcdensity\"<-function (x, digits = max(3, getOption(\"digits\") - 3), ...) \n{\n    cat(\"\\n\",x$modelname,\"\\n\\nCall:\\n\", sep = \"\")\n    print(x$call)\n    cat(\"\\n\")\n\n    cat(\"Posterior Predictive Distributions (log):\\n\")\t     \n    print.default(format(summary(log(x$cpo)), digits = digits), print.gap = 2, \n            quote = FALSE) \n            \n    cat(\"\\nPosterior Inference of Parameters:\\n\")\n    print.default(format(x$coefficients, digits = digits), print.gap = 2, \n            quote = FALSE)\n\n    cat(\"\\nNumber of Observations:\",x$nrec)\n    cat(\"\\nNumber of Predictors:\",x$nvar-1,\"\\n\")    \n    cat(\"\\n\\n\")\n    invisible(x)\n}\n\n\n\"summary.DPcdensity\"<-function(object, hpd=TRUE, ...) \n{\n    stde<-function(x)\n    {\n    \tn<-length(x)\n    \treturn(sd(x)/sqrt(n))\n    }\n\n    hpdf<-function(x)\n    {\n         alpha<-0.05\n         vec<-x\n         n<-length(x)         \n         alow<-rep(0,2)\n         aupp<-rep(0,2)\n         a<-.Fortran(\"hpd\",n=as.integer(n),alpha=as.double(alpha),x=as.double(vec),\n                     alow=as.double(alow),aupp=as.double(aupp),PACKAGE=\"DPpackage\")\n         return(c(a$alow[1],a$aupp[1]))\n    }\n    \n    pdf<-function(x)\n    {\n         alpha<-0.05\n         vec<-x\n         n<-length(x)         \n         alow<-rep(0,2)\n         aupp<-rep(0,2)\n         a<-.Fortran(\"hpd\",n=as.integer(n),alpha=as.double(alpha),x=as.double(vec),\n                     alow=as.double(alow),aupp=as.double(aupp),PACKAGE=\"DPpackage\")\n         return(c(a$alow[2],a$aupp[2]))\n    }\n\n    #nsave<-object$nsave\n    #dimen<-length(object$coefficients)\n    #thetasave<-matrix(object$save.state$thetasave,nrow=nsave, ncol=dimen)\n    thetasave<-object$save.state$thetasave\n\n    ans <- c(object[c(\"call\", \"modelname\")])\n\n### CPO\n    ans$cpo<-object$cpo\n\n### Baseline Information\n\n    mat<-NULL\n    coef.p<-NULL\n    \n    dimen1<-object$nvar+object$nvar*(object$nvar+1)/2+1\n\n    coef.p<-object$coefficients[1:dimen1]\n    mat<-thetasave[,1:dimen1]\n    \n    if(dimen1>0){\n    \n       coef.m <-apply(mat, 2, median)    \n       coef.sd<-apply(mat, 2, sd)\n       coef.se<-apply(mat, 2, stde)\n\n       if(hpd){             \n            limm<-apply(mat, 2, hpdf)\n            coef.l<-limm[1,]\n            coef.u<-limm[2,]\n       }\n       else\n       {\n            limm<-apply(mat, 2, pdf)\n            coef.l<-limm[1,]\n            coef.u<-limm[2,]\n       }\n\n       coef.table <- cbind(coef.p, coef.m, coef.sd, coef.se , coef.l , coef.u)\n       if(hpd)\n       {\n            dimnames(coef.table) <- list(names(coef.p), c(\"Mean\", \"Median\", \"Std. Dev.\", \"Naive Std.Error\",\n                   \"95%HPD-Low\",\"95%HPD-Upp\"))\n       }\n       else\n       {\n            dimnames(coef.table) <- list(names(coef.p), c(\"Mean\", \"Median\", \"Std. Dev.\", \"Naive Std.Error\",\n                   \"95%CI-Low\",\"95%CI-Upp\"))\n       }\n\n       ans$base<-coef.table\n    }\n\n### Precision parameter\n\n    dimen1<-object$nvar+object$nvar*(object$nvar+1)/2+1\n    \n    if(is.null(object$prior$a0))\n    {\n      dimen2<-1\n      coef.p<-object$coefficients[(dimen1+1)]\n      mat<-matrix(thetasave[,(dimen1+1)],ncol=1)\n    }\n    else\n    {\n      dimen2<-2\n      coef.p<-object$coefficients[(dimen1+1):(dimen1+2)]\n      mat<-thetasave[,(dimen1+1):(dimen1+2)]\n\n    }  \n\n    coef.m <-apply(mat, 2, median)    \n    coef.sd<-apply(mat, 2, sd)\n    coef.se<-apply(mat, 2, stde)\n\n    if(hpd){             \n         limm<-apply(mat, 2, hpdf)\n         coef.l<-limm[1,]\n         coef.u<-limm[2,]\n    }\n    else\n    {\n         limm<-apply(mat, 2, pdf)\n         coef.l<-limm[1,]\n         coef.u<-limm[2,]\n    }\n\n\n    coef.table <- cbind(coef.p, coef.m, coef.sd, coef.se , coef.l , coef.u)\n    \n    if(hpd)\n    {\n        dimnames(coef.table) <- list(names(coef.p), c(\"Mean\", \"Median\", \"Std. Dev.\", \"Naive Std.Error\",\n                \"95%HPD-Low\",\"95%HPD-Upp\"))\n    }\n    else\n    {\n        dimnames(coef.table) <- list(names(coef.p), c(\"Mean\", \"Median\", \"Std. Dev.\", \"Naive Std.Error\",\n                \"95%CI-Low\",\"95%CI-Upp\"))\n    }\n\n    ans$prec<-coef.table\n    ans$nrec<-object$nrec\n    ans$nvar<-object$nvar\n\n    class(ans) <- \"summaryDPcdensity\"\n    return(ans)\n}\n\n\n\"print.summaryDPcdensity\"<-function (x, digits = max(3, getOption(\"digits\") - 3), ...) \n{\n    cat(\"\\n\",x$modelname,\"\\n\\nCall:\\n\", sep = \"\")\n    print(x$call)\n    cat(\"\\n\")\n    \t     \n    cat(\"Posterior Predictive Distributions (log):\\n\")\t     \n    print.default(format(summary(log(as.vector(x$cpo))), digits = digits), print.gap = 2, \n            quote = FALSE) \n            \n    if (length(x$base)) {\n        cat(\"\\nBaseline distribution:\\n\")\n        print.default(format(x$base, digits = digits), print.gap = 2, \n            quote = FALSE)\n    }\n    else cat(\"No baseline parameters\\n\")\n\n    if (length(x$prec)) {\n        cat(\"\\nPrecision parameter:\\n\")\n        print.default(format(x$prec, digits = digits), print.gap = 2, \n            quote = FALSE)\n    }\n\n    cat(\"\\nNumber of Observations:\",x$nrec)\n    cat(\"\\nNumber of Predictors:\",x$nvar-1,\"\\n\")        \n    cat(\"\\n\\n\")\n    invisible(x)\n}\n\n\n\n\"plot.DPcdensity\"<-function(x, ask=TRUE, output=\"density\", param=NULL, hpd=TRUE, nfigr=1, nfigc=1, col=\"#bdfcc9\", ...) \n{\n\nfancydensplot1<-function(x, hpd=TRUE, npts=200, xlab=\"\", ylab=\"\", main=\"\",col=\"#bdfcc9\", ...)\n# Author: AJV, 2006\n#\n{\n\tdens <- density(x,n=npts)\n\tdensx <- dens$x\n\tdensy <- dens$y\n\n\tmeanvar <- mean(x)\n\tdensx1 <- max(densx[densx<=meanvar])\n\tdensx2 <- min(densx[densx>=meanvar])\n\tdensy1 <- densy[densx==densx1]\n\tdensy2 <- densy[densx==densx2]\n\tymean <- densy1 + ((densy2-densy1)/(densx2-densx1))*(meanvar-densx1)\n        \n\n\tif(hpd==TRUE)\n\t{\n\t\talpha<-0.05\n\t\talow<-rep(0,2)\n\t\taupp<-rep(0,2)\n\t\tn<-length(x)\n\t\ta<-.Fortran(\"hpd\",n=as.integer(n),alpha=as.double(alpha),x=as.double(x),\n\t\t                     alow=as.double(alow),aupp=as.double(aupp),PACKAGE=\"DPpackage\")\n\t\txlinf<-a$alow[1]            \n\t\txlsup<-a$aupp[1]            \n\t}\n\telse\n\t{\n\t\txlinf <- quantile(x,0.025)\n\t\txlsup <- quantile(x,0.975)\n\t}\n\n\tdensx1 <- max(densx[densx<=xlinf])\n\tdensx2 <- min(densx[densx>=xlinf])\n\tdensy1 <- densy[densx==densx1]\n\tdensy2 <- densy[densx==densx2]\n\tylinf <- densy1 + ((densy2-densy1)/(densx2-densx1))*(xlinf-densx1)\n\n\tdensx1 <- max(densx[densx<=xlsup])\n\tdensx2 <- min(densx[densx>=xlsup])\n\tdensy1 <- densy[densx==densx1]\n\tdensy2 <- densy[densx==densx2]\n\tylsup <- densy1 + ((densy2-densy1)/(densx2-densx1))*(xlsup-densx1)\n\n\tplot(0.,0.,xlim = c(min(densx), max(densx)), ylim = c(min(densy), max(densy)),\n             axes = F,type = \"n\" , xlab=xlab, ylab=ylab, main=main, cex=1.2)\n\n        \n\txpol<-c(xlinf,xlinf,densx[densx>=xlinf & densx <=xlsup],xlsup,xlsup)\n\typol<-c(0,ylinf,densy[densx>=xlinf & densx <=xlsup] ,ylsup,0)\n             \n\tpolygon(xpol, ypol, border = FALSE,col=col)\n        \n\tlines(c(min(densx), max(densx)),c(0,0),lwd=1.2)\n        \n\tsegments(min(densx),0, min(densx),max(densy),lwd=1.2)\n        \n\tlines(densx,densy,lwd=1.2)\n             \n\tsegments(meanvar, 0, meanvar, ymean,lwd=1.2)\n\tsegments(xlinf, 0, xlinf, ylinf,lwd=1.2)\n\tsegments(xlsup, 0, xlsup, ylsup,lwd=1.2)\n\n\taxis(1., at = round(c(xlinf, meanvar,xlsup), 2.), labels = T,pos = 0.)\n        axis(1., at = round(seq(min(densx),max(densx),length=15), 2.), labels = F,pos = 0.)\n        axis(2., at = round(seq(0,max(densy),length=5), 2.), labels = T,pos =min(densx))\n}\n\n   if(is(x, \"DPcdensity\"))\n   {\n      if(output==\"density\")\n      {\n      # Density estimation\n\t\tpar(ask = ask)\n\t\tlayout(matrix(seq(1,nfigr*nfigc,1),nrow=nfigr,ncol=nfigc,byrow=TRUE))\n\n        for(i in 1:x$npred)\n\t\t{\n               if(x$compute.band)\n               {\n                  title1 <- paste(\"Density Prediction #\",i,sep=\" \")           \n                  plot(x$grid,x$densp.h[i,],main=title1,lty=2,type='l',lwd=2,xlab=\"y\",ylab=\"density\")\n                  lines(x$grid,x$densp.l[i,],lty=2,lwd=2)\n                  lines(x$grid,x$densp.m[i,],lty=1,lwd=3)\n\t\t\t   }\n               else\n               {\n\t\t\t\t  title1 <- paste(\"Density Prediction #\",i,sep=\" \")           \n\t\t\t\t  plot(x$grid,x$densp.m[i,],main=title1,lty=1,type='l',lwd=2,xlab=\"y\",ylab=\"density\")\n\t\t\t   }\n\t\t}\n\n      }\n      else\n      {\n\n        if(is.null(param))\n        {\n           pnames<-colnames(x$save.state$thetasave)\n           n<-dim(x$save.state$thetasave)[2]\n           cnames<-names(x$coefficients)\n           \n           par(ask = ask)\n           layout(matrix(seq(1,nfigr*nfigc,1), nrow=nfigr , ncol=nfigc ,byrow=TRUE))\n           for(i in 1:(n-1))\n           {\n               title1<-paste(\"Trace of\",pnames[i],sep=\" \")\n               title2<-paste(\"Density of\",pnames[i],sep=\" \")       \n               plot(x$save.state$thetasave[,i],type='l',main=title1,xlab=\"MCMC scan\",ylab=\" \")\n               if(pnames[i]==\"ncluster\")\n               {\n                  hist(x$save.state$thetasave[,i],main=title2,xlab=\"values\", ylab=\"probability\",probability=TRUE)\n               }\n               else\n               {\n                 fancydensplot1(x$save.state$thetasave[,i],hpd=hpd,main=title2,xlab=\"values\", ylab=\"density\",col=col)\n               }\n           }\n           \n           if(is.null(x$prior$a0))\n           {\n               cat(\"\")\n           }\n           else\n           {\n               title1<-paste(\"Trace of\",pnames[n],sep=\" \")\n               title2<-paste(\"Density of\",pnames[n],sep=\" \")       \n               plot(x$save.state$thetasave[,n],type='l',main=title1,xlab=\"MCMC scan\",ylab=\" \")\n               fancydensplot1(x$save.state$thetasave[,n],hpd=hpd,main=title2,xlab=\"values\", ylab=\"density\",col=col)\n           }\n        }\n   \n        else\n        {\n\n            pnames<-colnames(x$save.state$thetasave)\n            n<-dim(x$save.state$thetasave)[2]\n\t\t\tposs<-0 \n            for(i in 1:n)\n            {\n               if(pnames[i]==param)poss=i\n            }\n            if (poss==0) \n\t\t\t{\n\t\t\t\tstop(\"This parameter is not present in the original model.\\n\")\n\t\t\t}\n\t    \n\t\t\tpar(ask = ask)\n\t\t\tlayout(matrix(seq(1,nfigr*nfigc,1), nrow=nfigr, ncol=nfigc, byrow = TRUE))\n            title1<-paste(\"Trace of\",pnames[poss],sep=\" \")\n            title2<-paste(\"Density of\",pnames[poss],sep=\" \")       \n            plot(x$save.state$thetasave[,poss],type='l',main=title1,xlab=\"MCMC scan\",ylab=\" \")\n            if(pnames[poss]==\"ncluster\")\n            {\n                hist(x$save.state$thetasave[,poss],main=title2,xlab=\"values\", ylab=\"probability\",probability=TRUE)\n            }\n            else\n            {\n               fancydensplot1(x$save.state$thetasave[,poss],hpd=hpd,main=title2,xlab=\"values\", ylab=\"density\",col=col)\n            }\n            \n        }\n      }\t\n   }\n}\n\n\n\n\n",
    "created" : 1491565156990.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4156476448",
    "id" : "EF3D80CF",
    "lastKnownWriteTime" : 1491566874,
    "last_content_update" : 1491566933923,
    "path" : "G:/STAFF/Michael Sachs/R projects/DPpackagemod/R/DPcdensity.R",
    "project_path" : "R/DPcdensity.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}